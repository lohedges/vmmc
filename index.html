<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="VMMC : A C++ library to implement the &quot;virtual-move&quot; Monte Carlo algorithm for approximating the dynamical evolution of systems of strongly interacting overdamped particles.">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
    <link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon" />
    <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">

    <title>VMMC</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/lohedges/vmmc">View on GitHub</a>

          <h1 id="project_title">LibVMMC</h1>
          <h2 id="project_tagline">A C++ library to implement the &quot;virtual-move&quot; Monte Carlo algorithm for approximating the dynamical evolution of systems of strongly interacting overdamped particles.</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/lohedges/vmmc/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/lohedges/vmmc/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">

<p>Copyright © 2015 <a href="http://lesterhedges.net">Lester Hedges</a>
<a href="http://www.gnu.org/licenses/gpl-3.0.html">
<img width="80" src="http://www.gnu.org/graphics/gplv3-127x51.png"></a></p>

<h2>
<a id="about" class="anchor" href="#about" aria-hidden="true"><span class="octicon octicon-link"></span></a>About</h2>

<p>A simple C++ library to implement the "virtual-move" Monte Carlo (VMMC)
algorithm of <a href="http://nanotheory.lbl.gov/people/SteveWhitelam.html">Steve Whitelam</a>
and <a href="http://www.cchem.berkeley.edu/plggrp/index.html">Phill Geissler</a>, see:</p>

<ul>
<li>Avoiding unphysical kinetic traps in Monte Carlo simulations of strongly
attractive particles,<br>S. Whitelam and P.L. Geissler,
<a href="http://dx.doi.org/10.1063/1.2790421">Journal of Chemical Physics, 127, 154101 (2007)</a>
</li>
</ul>

<blockquote>
<p>We introduce a “virtual-move” Monte Carlo algorithm for systems of
pairwise-interacting particles. This algorithm facilitates the simulation
of particles possessing attractions of short range and arbitrary strength
and geometry, an important realization being self-assembling particles
endowed with strong, short-ranged, and angularly specific (“patchy”)
attractions. Standard Monte Carlo techniques employ sequential updates
of particles and can suffer from low acceptance rates when attractions are
strong. In this event, collective motion can be strongly suppressed. Our
algorithm avoids this problem by proposing simultaneous moves of collections
(clusters) of particles according to gradients of interaction energies.
One particle first executes a “virtual” trial move. We determine which of
its neighbors move in a similar fashion by calculating individual bond
energies before and after the proposed move. We iterate this procedure and
update simultaneously the positions of all affected particles. Particles
move according to an approximation of realistic dynamics without requiring
the explicit computation of forces and without the step size restrictions
required when integrating equations of motion. We employ a size- and
shape-dependent damping of cluster movements, motivated by collective
hydrodynamic effects neglected in simple implementations of Brownian dynamics.</p>
</blockquote>

<ul>
<li>Approximating the dynamical evolution of systems of strongly interacting
overdamped particles, S. Whitelam,
<a href="http://dx.doi.org/10.1080/08927022.2011.565758">Molecular Simulation, 37 (7) (2011)</a>.
(Preprint version available <a href="http://arxiv.org/abs/1009.2008">here</a>.)</li>
</ul>

<p>Our primary goal is to make VMMC accessible to a wider audience, for whom the
time required to code the algorithm poses a significant barrier to using the
method. This allows the user to focus on model development.</p>

<p>The animation below shows a comparison of the dynamics generated by traditional
single-particle Monte Carlo (SPMC) and the VMMC algorithm for a periodic
two-dimensional <a href="http://www.sklogwiki.org/SklogWiki/index.php/Square_well_model">square-well fluid</a>.
The model system consists of particles interacting via strong, short-ranged
isotropic interactions. Due to the suppression of collective particle
rearrangements, SPMC results in the slow <a href="https://en.wikipedia.org/wiki/Ostwald_ripening">Ostwald ripening</a>
of isolated clusters. In contrast, VMMC facilitates the diffusion and
coalescence of particle clusters, resulting in a long-time dynamics that
is dominated by the motion of a single large cluster. Both trajectories
represent one billion trial moves of the respective algorithms, with the system
initialised with a random, non-overlapping, particle configuration in each case.</p>

<p><img width=620 src="https://raw.githubusercontent.com/lohedges/assets/master/vmmc/animations/comparison.gif" alt="Comparison of the single particle and virtual-move Monte Carlo algorithms."></p>

<p>The VMMC algorithm works by proposing the move of a single, randomly chosen,
"seed" particle. If, following the move, the change in the energy of interaction
between the particle and its neighbours is unfavourable, then those neighbours
are recruited and moved in concert. This process is iterated recursively for
each new recruit until no further particles show a tendency to move.</p>

<p>The animations below illustrate example VMMC translation and rotation moves
taken from a real simulation. Red indicates the most recent recruit to the
cluster, orange indicates the nearest neigbour to which link formation is
currently being tested, and green indicates those particles that have been
accepted as part of the cluster move. The animations show how a recursive
depth-first search is used to iteratively link particles to the cluster.
Particles are linked according to probabilities based on the pair interaction
energy differences following the forward and reverse virtual move of each
recruit. Computation of the reverse move is required to enforce superdetailed
balance, thus ensuring that the probability of a given particle pushing or
pulling on the cluster is the same.</p>

<p>
    <img width="310" src="https://raw.githubusercontent.com/lohedges/assets/master/vmmc/animations/translation.gif" alt="Example VMMC translation move.">
    <img width="310" src="https://raw.githubusercontent.com/lohedges/assets/master/vmmc/animations/rotation.gif" alt="Example VMMC rotation move.">
</p>

<h2>
<a id="installation" class="anchor" href="#installation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Installation</h2>

<p>A <code>Makefile</code> is included for building and installing LibVMMC.</p>

<p>To compile LibVMMC, then install the library, documentation, and demos:</p>

<div class="highlight highlight-bash"><pre>$ make build
$ make install</pre></div>

<p>By default, the library installs to <code>/usr/local</code>. Therefore, you may need admin
priveleges for the final <code>make install</code> step above. An alternative is to change
the install location:</p>

<div class="highlight highlight-bash"><pre>$ PREFIX=MY_INSTALL_DIR make install</pre></div>

<p>Further details on using the Makefile can be found by running make without
a target, i.e.</p>

<div class="highlight highlight-bash"><pre>$ make</pre></div>

<h2>
<a id="compiling-and-linking" class="anchor" href="#compiling-and-linking" aria-hidden="true"><span class="octicon octicon-link"></span></a>Compiling and linking</h2>

<p>To use LibVMMC with a C/C++ code first include the LibVMMC header file somewhere
in the code.</p>

<div class="highlight highlight-cpp"><pre><span class="pl-c">//example.cpp</span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>vmmc/VMMC.h<span class="pl-pds">&gt;</span></span></pre></div>

<p>Then to compile, we can use something like the following:</p>

<div class="highlight highlight-bash"><pre>$ g++ -std=c++11 example.cpp -lvmmc</pre></div>

<p>This assumes that we have used the default install location <code>/usr/local</code>. If
we specify an install location, we would use a command more like the following:</p>

<div class="highlight highlight-bash"><pre>$ g++ -std=c++11 example.cpp -I/my/path/include -L/my/path/lib -lvmmc</pre></div>

<p>Note that the <code>-std=c++11</code> compiler flag is needed for <code>std::function</code> and
<code>std::random</code>.</p>

<h2>
<a id="dependencies" class="anchor" href="#dependencies" aria-hidden="true"><span class="octicon octicon-link"></span></a>Dependencies</h2>

<p>LibVMMC uses the <a href="http://en.wikipedia.org/wiki/Mersenne_Twister">Mersenne Twister</a>
psuedorandom number generator. A C++11 implementation using <code>std::random</code> is
included as a bundled header file, <code>MersenneTwister.h</code>. See the source code or
generate Doxygen documentation with <code>make doc</code> for details on how to use it.</p>

<h2>
<a id="callback-functions" class="anchor" href="#callback-functions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Callback functions</h2>

<p>LibVMMC works via several user-defined callback functions that abstract model
specific details, such as the pair potential. We make use of C++11's
<code>std::function</code> to provide a general-purpose function wrapper, i.e.
the callbacks can be free functions, member functions, etc. These callbacks
allow LibVMMC to be blind to the implementation of the model, as well as
the model to be blind to the details of the VMMC algorithm. The generic
nature of the function wrapper provides great flexibility to the user, freeing
them from a specific design choice for the model in hand. It is possible to
glue together components written in different ways, or to use the callbacks
themselves as C/C++ wrappers to external libraries.</p>

<p>An alternative version of LibVMMC that shows how to achieve the same callback
functionality using a pure abstract <code>Model</code> base class can be found in the
<code>pure-abstract</code> branch. While this provides a cleaner interface, the additional
flexibility provided by <code>std::function</code> more than offsets the minimal
performance cost.</p>

<p>Details of the callback prototypes are given below (where <code>typedef</code> has
been used to simplify their declaration).</p>

<h3>
<a id="particle-energy" class="anchor" href="#particle-energy" aria-hidden="true"><span class="octicon octicon-link"></span></a>Particle energy</h3>

<p>Calculate the total pair interaction energy felt by a particle.</p>

<div class="highlight highlight-cpp"><pre><span class="pl-k">typedef</span> std::function&lt;<span class="pl-k">double</span> (<span class="pl-k">unsigned</span> <span class="pl-k">int</span> index, <span class="pl-k">double</span> position[],
    <span class="pl-k">double</span> orientation[])&gt; EnergyCallback;</pre></div>

<p><code>index</code> = The particle index.</p>

<p><code>position</code> = An x, y, z (or x, y in 2D) coordinate vector for the particle.</p>

<p><code>orientation</code> = The particle's orientation unit vector.</p>

<p>This callback function is currently somewhat redundant since it is possible to
achieve the same outcome by combining the <code>PairEnergyCallback</code> and
<code>InteractionsCallback</code> functions described below. Ultimately, the callback
will be able to account for non-pairwise terms in the potential, such as
an external field.</p>

<h3>
<a id="pair-energy" class="anchor" href="#pair-energy" aria-hidden="true"><span class="octicon octicon-link"></span></a>Pair energy</h3>

<p>Calculate the pair interaction between two particles.</p>

<div class="highlight highlight-cpp"><pre><span class="pl-k">typedef</span> std::function&lt;<span class="pl-k">double</span> (<span class="pl-k">unsigned</span> <span class="pl-k">int</span> index1, <span class="pl-k">double</span> position1[],
    <span class="pl-k">double</span> orientation1[], <span class="pl-k">unsigned</span> <span class="pl-k">int</span> index2, <span class="pl-k">double</span> position2[],
    <span class="pl-k">double</span> orientation2[])&gt; PairEnergyCallback;</pre></div>

<p><code>index1</code> = The index of the first particle.</p>

<p><code>position1</code> = The coordinate vector of the first particle.</p>

<p><code>orientation1</code> = The orientation unit vector of the first particle.</p>

<p><code>index2</code> = The index of the second particle.</p>

<p><code>position2</code> = The coordinate vector of the second particle.</p>

<p><code>orientation2</code> = The orientation unit vector of the second particle.</p>

<h3>
<a id="interactions" class="anchor" href="#interactions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Interactions</h3>

<p>Determine the interactions for a given particle.</p>

<div class="highlight highlight-cpp"><pre><span class="pl-k">typedef</span> std::function&lt;<span class="pl-k">unsigned</span> <span class="pl-en">int</span> (<span class="pl-k">unsigned</span> <span class="pl-k">int</span> index, <span class="pl-k">double</span> position[],
    <span class="pl-k">double</span> orientation[], <span class="pl-k">unsigned</span> <span class="pl-k">int</span> interactions[])&gt; InteractionsCallback;</pre></div>

<p><code>index</code> = The index of the  particle.</p>

<p><code>position</code> = The coordinate vector of the particle.</p>

<p><code>orientation</code> = The orientation unit vector of the particle.</p>

<p><code>interactions</code> = An array to store the indices of the interactions.</p>

<h3>
<a id="post-move" class="anchor" href="#post-move" aria-hidden="true"><span class="octicon octicon-link"></span></a>Post-move</h3>

<p>Apply any post-move updates, e.g. update cell lists, or neighbour lists.</p>

<div class="highlight highlight-cpp"><pre><span class="pl-k">typedef</span> std::function&lt;<span class="pl-k">void</span> (<span class="pl-k">unsigned</span> <span class="pl-k">int</span> index, <span class="pl-k">double</span> position[],
    <span class="pl-k">double</span> orientation[])&gt; PostMoveCallback;</pre></div>

<p><code>index</code> = The index of the  particle.</p>

<p><code>position</code> = The coordinate vector of the particle following the move.</p>

<p><code>orientation</code> = The orientation unit vector of the particle following the move.</p>

<h3>
<a id="boundary-condition" class="anchor" href="#boundary-condition" aria-hidden="true"><span class="octicon octicon-link"></span></a>Boundary condition (optional)</h3>

<p>Test for a custom boundary condition. This should return true if the particle
moves outside of the boundary following the virtual move. An example showing how
to implement custom boundary conditions is provided with the demonstration code.</p>

<div class="highlight highlight-cpp"><pre><span class="pl-k">typedef</span> std::function&lt;<span class="pl-k">bool</span> (<span class="pl-k">unsigned</span> <span class="pl-k">int</span> index, <span class="pl-k">double</span> position[],
    <span class="pl-k">double</span> orientation[])&gt; BoundaryCallback;</pre></div>

<p><code>index</code> = The index of the  particle.</p>

<p><code>position</code> = The coordinate vector of the particle following the move.</p>

<p><code>orientation</code> = The orientation unit vector of the particle following the move.</p>

<h2>
<a id="assigning-a-callback" class="anchor" href="#assigning-a-callback" aria-hidden="true"><span class="octicon octicon-link"></span></a>Assigning a callback</h2>

<p>Using the callbacks above it is easy to create a function wrapper to whatever,
e.g.</p>

<div class="highlight highlight-cpp"><pre>vmmc::EnergyCallback energyCallback = computeEnergy;</pre></div>

<p>if <code>computeEnergy</code> were a free function, or</p>

<div class="highlight highlight-cpp"><pre>Foo foo;
<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span>::placeholders<span class="pl-k">;</span>
vmmc::EnergyCallback energyCallback = std::bind(&amp;Foo::computeEnergy, foo, _1, _2, _3);</pre></div>

<p>if <code>computeEnergy</code> were instead a member of some object called <code>Foo</code>.</p>

<p>For simplicity we provide a container for callback functions. This simplifies
assignment and makes it possible to pass a single callback argument to the
constructor of the VMMC object.</p>

<div class="highlight highlight-cpp"><pre><span class="pl-k">struct</span>
{
    <span class="pl-k">EnergyCallback</span> energyCallback;
    <span class="pl-k">PairEnergyCallback</span> pairEnergyCallback;
    <span class="pl-k">InteractionsCallback</span> InteractionsCallback;
    <span class="pl-k">PostMoveCallback</span> postMoveCallback;
    <span class="pl-k">BoundaryCallback</span> boundaryCallback;
};</pre></div>

<p>In the second example above, initialisation of the energyCallback function would become</p>

<div class="highlight highlight-cpp"><pre>Foo foo;
<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span>::placeholders<span class="pl-k">;</span>
vmmc::CallbackFunctions callbacks;
callbacks.energyCallback = std::bind(&amp;Foo::computeEnergy, foo, _1, _2, _3);</pre></div>

<h2>
<a id="the-vmmc-object" class="anchor" href="#the-vmmc-object" aria-hidden="true"><span class="octicon octicon-link"></span></a>The VMMC object</h2>

<p>To use LibVMMC you will want to create an instance of the VMMC object. This has the following
constructor:</p>

<div class="highlight highlight-cpp"><pre><span class="pl-en">VMMC</span>(<span class="pl-k">unsigned</span> <span class="pl-k">int</span> nParticles, <span class="pl-k">unsigned</span> <span class="pl-k">int</span> dimension, <span class="pl-k">double</span> coordinates[],
    <span class="pl-k">double</span> orientations[], <span class="pl-k">double</span> maxTrialTranslation, <span class="pl-k">double</span> maxTrialRotation,
    <span class="pl-k">double</span> probTranslate, <span class="pl-k">double</span> referenceRadius, <span class="pl-k">unsigned</span> <span class="pl-k">int</span> maxInteractions,
    <span class="pl-k">double</span> boxSize[], <span class="pl-k">bool</span> isIsotropic[], <span class="pl-k">bool</span> isRepulsive,
    <span class="pl-k">const</span> CallbackFunctions&amp; callbacks);</pre></div>

<p><code>nParticles</code> = The number of particles in the simulation box.</p>

<p><code>dimension</code> = The dimension of the simulation box (either 2 or 3).</p>

<p><code>coordinates</code> = An array containing coordinates for all of the particles in the
system, i.e. <code>x1, y1, z1, x2, y2, z2, ... , xN, yN, zN.</code>
Coordinates should run from 0 to the box size in each dimension.</p>

<p><code>orientations</code> = An array containing orientations (unit vectors) for all of the
particles in the system, i.e. <code>nx1, ny1, nz1, nx2, ny2, nz2, ... , nxN, nyN, nzN.</code>
In the case of particles interacting via an isotropic potential, the particle
orientations are entirely redundant, i.e. the orientation has no effect on the
potential. This allows the use of a single set of callback functions for models
with both isotropic and anisotropic potentials.</p>

<p><code>maxTrialTranslation</code> = The maximum trial translation, in units of the particle
diameter (or typical particle size).</p>

<p><code>maxTrialRotation</code> = The maximum trial rotation in radians.</p>

<p><code>probTranslate</code> = The probability of attempting a translation move (relative to rotations).
Along with <code>maxTrialTranslation</code> and <code>maxTrialRotation</code>, <code>probTranslate</code> can be tuned to
enforce an approximate Stokes drag. An excellent and detailed explanation of how this may
be applied in practice can be found
<a href="http://nanotheory.lbl.gov/people/design_rules_paper/methods.pdf">here</a>.</p>

<p><code>referenceRadius</code> = A reference radius for computing the approximate hydrodynamic
damping factor, e.g. the radius of a typical particle in the system.</p>

<p><code>maxInteractions</code> = The maximum number of pair interactions that an individual
particle can make. This will be used to resize LibVMMC's internal data
structures and the user should assert that this limit isn't exceed in the
<code>InteractionsCallback</code> function. The number can be chosen from the symmetry
of the system, e.g. if particles can only make a certain number of patchy
interactions, or by estimating the average number of neighbours within the
interaction volume around a particle.</p>

<p><code>boxSize</code> = The base length of the simulation box in each dimension.</p>

<p><code>isIsotropic</code> = Whether the potential of each particle is isotropic. The
handling of rotational moves is slightly different for moves seeded from
isotropic particles, e.g. spheres, since the rotation of the seed causes
no change in energy. This boolean array allows LibVMMC to handle
mixed-potential systems.</p>

<p><code>isRepulsive</code> = Whether the potential has finite energy repulsions. This should
also be set to <code>true</code> when particle interactions contain a mixture of hard core
overlaps and finite repulsions.</p>

<p><code>callbacks</code> = The callback function container.</p>

<h2>
<a id="c-style-arrays" class="anchor" href="#c-style-arrays" aria-hidden="true"><span class="octicon octicon-link"></span></a>C-style arrays</h2>

<p>The VMMC object constructor and callback functions use C-style arrays as
arguments for simplicity and generality. This (hopefully) makes it as easy
as possible for a user unfamiliar with C++ to make use of LibVMMC (although
everyone should take time to learn <code>std::vector</code>). We can also exploit the
fact that the C++ standard imposes that <code>std::vector</code> elements are contiguous,
which allows <code>std::vector</code> containers to be passed as naked arrays.</p>

<p>For example, if we have some function called <code>foo</code> that accepts a C-style
double array as an argument,</p>

<div class="highlight highlight-cpp"><pre><span class="pl-k">void</span> <span class="pl-en">foo</span>(<span class="pl-k">double</span> arr[]);</pre></div>

<p>then both of the following are valid function calls</p>

<div class="highlight highlight-cpp"><pre><span class="pl-c">// C style</span>
<span class="pl-k">double</span> c_arr[<span class="pl-c1">10</span>];
<span class="pl-en">foo</span>(c_arr);

<span class="pl-c">// C++ style</span>
std::vector&lt;<span class="pl-k">double</span>&gt; <span class="pl-en">cpp_arr</span>(<span class="pl-c1">10</span>);
<span class="pl-en">foo</span>(&amp;cpp_arr[<span class="pl-c1">0</span>]);</pre></div>

<p>Internally, LibVMMC uses <code>std::vector</code> containers for its data structures, with
data passed to the callback functions in the manner described above.</p>

<h2>
<a id="executing-a-virtual-move" class="anchor" href="#executing-a-virtual-move" aria-hidden="true"><span class="octicon octicon-link"></span></a>Executing a virtual move</h2>

<p>Once an instance of the VMMC object is created, e.g.</p>

<div class="highlight highlight-cpp"><pre><span class="pl-en">VMMC</span>(...) vmmc;</pre></div>

<p>then a single trial move can be executed as follows:</p>

<div class="highlight highlight-cpp"><pre>vmmc.step();</pre></div>

<p>To perform 1000 trial moves:</p>

<div class="highlight highlight-cpp"><pre>vmmc.step(<span class="pl-c1">1000</span>);</pre></div>

<p>The same can be achieved by using the overloaded <code>++</code> and <code>+=</code> operators,
i.e. <code>vmmc++</code> for a single step, and <code>vmmc += 1000</code> for 1000 steps.</p>

<h2>
<a id="demos" class="anchor" href="#demos" aria-hidden="true"><span class="octicon octicon-link"></span></a>Demos</h2>

<p>The following example codes showing how to interface with LibVMMC are included
in the <code>demos</code> directory.</p>

<ul>
<li>
<code>square_wellium.cpp</code>: A simulation of a square-well fluid in two- or three-dimensions.</li>
<li>
<code>lennard_jonesium.cpp</code>: A simulation of a Lennard-Jones fluid in two- or three-dimensions.</li>
<li>
<code>patchy_disc.cpp</code>: A simulation of a two dimensional patchy disc model.</li>
</ul>

<p>When run, each of the demos output a trajectory file, <code>trajectory.xyz</code>, and a
TcL script, <code>vmd.tcl</code>, that can be used to set camera and particle attributes
and to draw the periodic simulation box when visualising the trajectory with
<a href="http://www.ks.uiuc.edu/Research/vmd/">VMD</a>. To generate and view a trajectory,
run, e.g.</p>

<div class="highlight highlight-bash"><pre>$ ./demos/square_wellium
$ vmd trajectory.xyz -e vmd.tcl</pre></div>

<p>The demo code also illustrates how to implement efficient, dynamically
updated cell lists. See <code>demos/src/CellList.h</code> and <code>demos/src/CellList.cpp</code>
for implementation details.</p>

<p>Also included in the <code>demos/python</code> directory are examples showing how to
interface with Python code via the <a href="https://docs.python.org/2/c-api/">Python C API</a>.
Note that this code is intended to be used for illustrative purposes and
avoids the use of additional dependencies (e.g. <a href="http://www.numpy.org">NumPy</a>).
As such, it is likely that performance could be significantly improved.</p>

<h2>
<a id="tests" class="anchor" href="#tests" aria-hidden="true"><span class="octicon octicon-link"></span></a>Tests</h2>

<p>A full test suite is forthcoming. This will allow a detailed comparison between
VMMC and standard single-move Monte Carlo (SPMC) for various model systems at a
range of state points.</p>

<p>Shown below are time-averaged pair distribution functions for Lennard-Jonesium
and the square-well fluid taken from configurations equilibrated using the demo
codes outlined above (although run for 10 times as long). In both cases the
equilibrated structures are indistinguishable from those generated by SPMC.
Note that the pair distribution functions don't converge to one at large
particle separations since we are not considering a bulk system, rather a
finite cluster in a background vapour. See the demos codes
<code>demos/lennard_jonesium.cpp</code> and <code>demos/square_wellium.cpp</code> for details
of the interaction parameters (Lennard-Jonesium is sampled in the liquid
phase, the square-well fluid is sampled in the crystal (FCC/HCP) phase).</p>

<p><img width=620 src="https://raw.githubusercontent.com/lohedges/assets/master/vmmc/images/pair-distribution.png" alt="Comparison of pair distribution functions for configurations equilibrated with SPMC and VMMC."></p>

<h2>
<a id="defining-a-model" class="anchor" href="#defining-a-model" aria-hidden="true"><span class="octicon octicon-link"></span></a>Defining a model</h2>

<p>The demo code illustrates a simple way of defining and handling different model
potentials. A base class, <code>Model</code>, is used to declare default functionality and
callbacks. Derived classes, such as <code>LennardJonesium</code>, are used to implement the
model specific pair potential, which is declared as a virtual method in the base
class.</p>

<p>Declaring a new user-defined model should be as easy as creating a <code>UserModel</code>
class with public inheritance from the <code>Model</code> base class, then overriding
the virtual <code>computePairEnergy</code> method. The <code>LennardJonesium</code>, <code>SquareWellium</code>,
and <code>PatchyDisc</code> classes will serve as useful templates.</p>

<h2>
<a id="pure-isotropic-systems" class="anchor" href="#pure-isotropic-systems" aria-hidden="true"><span class="octicon octicon-link"></span></a>Pure isotropic systems</h2>

<p>The default build of LibVMMC provides support for systems of isotropic and
anisotropic particles, or mixtures of both. However, in the case of pure
isotropic systems, e.g. spherical particles interacting via a spherically
symmetric potential, such as the square-well fluid, particle orientations
are entirely redundant since they have no bearing on the potential. This
means that there is no need to pass orientations as arguments to callback
functions, or to update particle orientations during VMMC trial moves.</p>

<p>We provide preprocessor directives that allow LibVMMC to be compiled as an
optimised library for pure isotropic systems. This can be achieved as follows:</p>

<div class="highlight highlight-bash"><pre>$ OPTFLAGS=-DISOTROPIC make build</pre></div>

<p>The isotropic version of LibVMMC provides a simplified set of callback
functions that require no particle orientations. For example, the
<code>PairEnergyCallback</code> becomes</p>

<div class="highlight highlight-cpp"><pre><span class="pl-k">typedef</span> std::function&lt;<span class="pl-k">double</span> (<span class="pl-k">unsigned</span> <span class="pl-k">int</span> index1, <span class="pl-k">double</span> position1[],
    <span class="pl-k">unsigned</span> <span class="pl-k">int</span> index2, <span class="pl-k">double</span> position2[])&gt; PairEnergyCallback;</pre></div>

<p>In addition, the VMMC object no longer needs the <code>orientations</code> or
<code>isIsotropic</code> arrays to be passed to its constructor, which is simplified to</p>

<div class="highlight highlight-cpp"><pre><span class="pl-en">VMMC</span>(<span class="pl-k">unsigned</span> <span class="pl-k">int</span> nParticles, <span class="pl-k">unsigned</span> <span class="pl-k">int</span> dimension, <span class="pl-k">double</span> coordinates[],
    <span class="pl-k">double</span> maxTrialTranslation, <span class="pl-k">double</span> maxTrialRotation, <span class="pl-k">double</span> probTranslate,
    <span class="pl-k">double</span> referenceRadius, <span class="pl-k">unsigned</span> <span class="pl-k">int</span> maxInteractions, <span class="pl-k">double</span> boxSize[],
    <span class="pl-k">bool</span> isRepulsive, <span class="pl-k">const</span> CallbackFunctions&amp; callbacks);</pre></div>

<p>The demo code shows how preprocessor directives can be used to provide support
for either version of the library, e.g. for the default <code>computeEnergy</code> callback
defined in the <code>Model</code> class, we have</p>

<div class="highlight highlight-cpp"><pre>#<span class="pl-k">ifndef</span> ISOTROPIC
    <span class="pl-k">virtual</span> <span class="pl-k">double</span> <span class="pl-en">computeEnergy</span>(<span class="pl-k">unsigned</span> <span class="pl-k">int</span>, <span class="pl-k">double</span>[], <span class="pl-k">double</span>[]);
#<span class="pl-k">else</span>
    <span class="pl-k">virtual</span> <span class="pl-k">double</span> <span class="pl-en">computeEnergy</span>(<span class="pl-k">unsigned</span> <span class="pl-k">int</span>, <span class="pl-k">double</span>[]);
#<span class="pl-k">endif</span></pre></div>

<p>The pure isotropic version of LibVMMC can provide a significant performance
gain when executing rotations of large clusters in isotropic systems.</p>

<p>Note that the demo <code>patchy_disc.cpp</code> will not compile against the isotropic
version of the library since the model is anisotropic and requires that
particle orientations are passed to its callback functions.</p>

<h2>
<a id="limitations" class="anchor" href="#limitations" aria-hidden="true"><span class="octicon octicon-link"></span></a>Limitations</h2>

<ul>
<li>The calculation of the hydrodynamic damping factor assumes a spherical cluster,
which is only approximate in two dimensions. In general, it is likely that
particles on a flat surface may diffuse in a system-specific way, so there may
be no good general approximation of Stokes scaling in two dimensions. In future
versions we intend to provide an additional callback function so that the user can
enforce a model-specific damping factor.</li>
<li>The recursive manner in which the trial cluster is built can lead to a stack
overflow if the cluster contains many particles. Typically, thousands, or tens
of thousands of particles should be perfectly manageable. The typical memory
footprint for a simulation of 1000 particles is around 2.5MB for hard particles.
This is roughly doubled if the potential has finite energy repulsions.</li>
</ul>

<h2>
<a id="efficiency" class="anchor" href="#efficiency" aria-hidden="true"><span class="octicon octicon-link"></span></a>Efficiency</h2>

<p>In aid of generality there are several sources of redundancy that impact the
efficiency of the VMMC implementation. As written, LibVMMC performs around 3-4
times worse than a fully optimised VMMC code for square-well fluids. A few
efficiency considerations are listed below in case the user wishes to modify
the VMMC source code in order to improve performance.</p>

<ul>
<li>When calculating a list of neighbours with which a given particle interacts
it's likely that you'll need to calculate the pair interaction energy. For
certain models it may be more efficient to return a list of pair energies
along with the interactions, rather than having to recalculate them.</li>
<li>For models with an isotropic interaction of fixed energy scale the pair
energy is simply a constant. As such, the pair energy calculation is entirely
redundant, i.e. knowing that two particles interact is enough to know the
pair energy.</li>
<li>If using cell lists, the typical size of a trial displacement will be small
enough such that a particle stays within the same neighbourhood of cells
following the trial move. (This isn't necessarily true for rotation moves,
where the displacement of particles far from the rotation axis can be large.)
As such, there is often no need to update cell lists until confirming that
the post-move configuration is valid, e.g. no overlaps. At present the same
<code>PostMoveCallback</code> function is called twice: once in order to apply the move;
again if the move is subsequently rejected. This means that the cell lists
will be updated twice if a move is rejected.</li>
<li>When testing for particle overlaps following a virtual move it is normally
not necessary to test pairs within the moving cluster. As written, all links
are tested, not just those external to the cluster. Note that <em>all</em> internal
pairs should be tested following a rotational move since it's possible to
rotate a cluster on top of itself. This can occur in a dense system when one
axis of a cluster is longer than the box size, e.g. the cluster lies diagonally
in a square box. In this case, a rotation across the periodic boundary can cause
the cluster to overlap.</li>
<li>Due to the overhead of binding member functions it is marginally faster to use
free functions as callbacks.</li>
</ul>

<h2>
<a id="tips" class="anchor" href="#tips" aria-hidden="true"><span class="octicon octicon-link"></span></a>Tips</h2>

<ul>
<li>LibVMMC currently assumes that the simulation box is periodic in all dimensions.
To impose non-periodic boundaries simply check whether the move leads to a particle
being displaced by more than half the box width along the restricted dimension and
return an appropriately large energy so that the move will be rejected.</li>
<li>It is not a requirement that all particles in the simulation box be of the same
type. Make use of the particle indices that are passed to callback functions in
order to distinguish different species.</li>
<li>The use of <code>std::function</code> allows the user to wrap arbitary functions as callbacks
(rather than only using free functions, as with C-style function pointers). See
<a href="http://en.cppreference.com/w/cpp/utility/functional/function">here</a> for details
on how to bind member functions, or function objects.</li>
</ul>

<h2>
<a id="citing-libvmmc" class="anchor" href="#citing-libvmmc" aria-hidden="true"><span class="octicon octicon-link"></span></a>Citing LibVMMC</h2>

<p>If you make use of LibVMMC in any published research please cite the canonical VMMC reference:</p>

<ul>
<li>Avoiding unphysical kinetic traps in Monte Carlo simulations of strongly
attractive particles,</br>S. Whitelam and P.L. Geissler,
<a href="http://dx.doi.org/10.1063/1.2790421">Journal of Chemical Physics, 127, 154101 (2007)</a>
</li>
</ul>

<p>and the symmetrised version of the algorithm described in the appendix of</p>

<ul>
<li>The role of collective motion in examples of coarsening and self-assembly,</br>
S. Whitelam, E.H. Feng, M.F. Hagan, and P.L. Geissler,
<a href="http://dx.doi.org/10.1039/B810031D">Soft Matter, 5, 1251 (2009)</a>
</li>
</ul>

<p>Please also include a citation to the official LibVMMC page:</p>

<ul>
    <li><a href="http://vmmc.xyz">http://vmmc.xyz</a></li>
</ul>

<p>A properly formatted BibTex file is provided <a href="https://raw.githubusercontent.com/lohedges/assets/master/vmmc/vmmc.bib" download>
here</a>.</p>

<h2>
<a id="disclaimer" class="anchor" href="#disclaimer" aria-hidden="true"><span class="octicon octicon-link"></span></a>Disclaimer</h2>

<p>Please be aware that this a working repository so the code should be used at
your own risk. At present the code is being tested so expect that it will be
updated fairly frequently with additional features and performance enhancements.</p>

</section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
      <div>
      <p style="float:left">&copy; 2015 <a href="http://lesterhedges.net">Lester Hedges</a></p>
      <p style="float:right">
        <a href="https://github.com/lohedges"><i class="fa fa-github-square fa-2x"></i></a>
        <a href="https://uk.linkedin.com/in/lesterhedges"><i class="fa fa-linkedin-square fa-2x"></i></a>
        <a href="mailto:lester.hedges+vmmc@gmail.com"><i class="fa fa-envelope-square fa-2x"></i></a>
      </p>
      </div>
      </footer>
    </div>

              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-38348443-2");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>


  </body>
</html>
